(in-package #:org.shirakumo.fraf.leaf)

(define-subject moving (game-entity)
  ((collisions :initform (make-array 4 :initial-element NIL) :reader collisions)
   (acceleration :initform (vec2 0 0) :accessor acceleration)
   (q-final :initform (vec2 0 0) :accessor q-final)))

(defmethod scan (entity target))

(defmethod tick ((moving moving) ev)
  (let* ((surface (surface moving))
         (loc (location moving))
         (vel (velocity moving))
         (size (bsize moving))
         (collisions (collisions moving))
         (q-final (v+ loc (v* vel (* 100 (dt ev))))))
    ;; Scan for hits
    (setf (q-final moving) q-final)
    (fill collisions NIL)
    (loop repeat 10
          do (unless (scan surface moving) (return))
             ;; KLUDGE: If we have too many collisions in a frame, we assume
             ;;         we're stuck somewhere, so just die.
          finally (die moving))
    ;; Set location = to q-final now
    (format t "q-final ~a velocity ~a ~%" (q-final moving) (velocity moving))
    (setf (location moving) (q-final moving))
    ;; Remaining velocity (if any) can be added safely.
    ;(nv+ loc (v* vel (* 100 (dt ev))))
    ;(vsetf vel 0 0)
    ;; Point test for adjacent walls
    (let ((l (scan surface (vec (- (vx loc) (vx size) 1) (vy loc))))
          (r (scan surface (vec (+ (vx loc) (vx size) 1) (vy loc))))
          (u (scan surface (vec (vx loc) (+ (vy loc) (vy size) 1) (vx size) 1))))
      (when l (setf (aref collisions 3) l (q-final moving) (vec 0 0)))
      (when r (setf (aref collisions 1) r (q-final moving) (vec 0 0)))
      (when u (setf (aref collisions 0) u (q-final moving) (vec 0 0))))))

(defmethod collides-p ((moving moving) (block block) hit)
  ;; KLUDGE: Ignore topmost edge pixel when we hit sides to allow better interaction with slopes
  (or (= 0 (vx (hit-normal hit)))
      (< (- (vy (location moving)) (vy (hit-location hit)))
         (1- (+ (vy (bsize moving)) (/ +tile-size+ 2))))))

(defmethod collide ((moving moving) (block block) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (normal (hit-normal hit))
         (height (vy (bsize moving)))
         (t-s (/ (block-s block) 2)))
    (cond ((= +1 (vy normal)) (setf (svref (collisions moving) 2) block))
          ((= -1 (vy normal)) (setf (svref (collisions moving) 0) block))
          ((= +1 (vx normal)) (setf (svref (collisions moving) 3) block))
          ((= -1 (vx normal)) (setf (svref (collisions moving) 1) block)))
    (nv+ loc (v* vel (hit-time hit)))
    ;(nv- vel (v* normal (v. vel normal)))
    ;; Zip out of ground in case of clipping
    (cond ((and (/= 0 (vy normal))
                 (< (vy pos) (vy loc))
                 (< (- (vy loc) height)
                    (+ (vy pos) t-s)))
           (setf (vy loc) (+ (vy pos) t-s height)))
          ((and (/= 0 (vy normal))
                (< (vy loc) (vy pos))
                (< (- (vy pos) t-s)
                   (+ (vy loc) height)))
           (setf (vy loc) (- (vy pos) t-s height))))))

(defmethod collides-p ((moving moving) (block platform) hit)
  (and (< (vy (velocity moving)) 0)
       (<= (+ (vy (hit-location hit)) (floor +tile-size+ 2))
           (- (vy (location moving)) (vy (bsize moving))))))

(defmethod collide ((moving moving) (block platform) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (normal (hit-normal hit))
         (height (vy (bsize moving)))
         (t-s (/ (block-s block) 2)))
    (setf (svref (collisions moving) 2) block)
    ;(nv+ loc (v* vel (hit-time hit)))
    ;(nv- vel (v* normal (v. vel normal)))
    ;; Zip
    (when (< (- (vy loc) height)
             (+ (vy pos) t-s))
      (setf (vy loc) (+ (vy pos) t-s height)))))

(defmethod collide ((moving moving) (block spike) hit)
  (die moving))

(defmethod collides-p ((moving moving) (block slope) hit)
  (let ((tt (slope (location moving) (velocity moving) (bsize moving) block (hit-location hit))))
    (when tt
      (setf (hit-time hit) tt)
      (setf (hit-normal hit) (nvunit (vec2 (- (vy2 (slope-l block)) (vy2 (slope-r block)))
                                           (- (vx2 (slope-r block)) (vx2 (slope-l block)))))))))

(defmethod collide ((moving moving) (block slope) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (q-final (q-final moving))
         (normal (hit-normal hit)))
    (setf (svref (collisions moving) 2) block)
    (let ((p1 loc) ; from lengyel 8.3
          (q (v+ loc (v* vel (hit-time hit))))
          (p2 q-final))
      (setf (q-final moving) (v- p2 (v* normal (v. normal (v- p2 q))))))
    ;(nv+ loc (v* vel (hit-time hit)))
    ;(nv- vel (v* normal (v. vel normal)))
    ;; Zip
    (let* ((xrel (/ (- (vx loc) (vx (hit-location hit))) +tile-size+)))
      (when (< (vx normal) 0) (incf xrel))
      ;; KLUDGE: we add a bias of 0.1 here to ensure we stop colliding with the slope.
      (let ((yrel (lerp (vy (slope-l block)) (vy (slope-r block)) xrel)))
        ;(format t "loc ~a vel ~a normal ~a~%" loc vel normal)
        (setf (vy loc) (+ yrel (vy (bsize moving)) (vy (hit-location hit))))))))

(defmethod collide ((moving moving) (other game-entity) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (location other))
         (normal (hit-normal hit))
         (bsize (bsize moving))
         (psize (bsize other)))
    (cond ((= +1 (vy normal)) (setf (svref (collisions moving) 2) other))
          ((= -1 (vy normal)) (setf (svref (collisions moving) 0) other))
          ((= +1 (vx normal)) (setf (svref (collisions moving) 3) other))
          ((= -1 (vx normal)) (setf (svref (collisions moving) 1) other)))
    (nv+ loc (v* (v- vel (velocity other)) 0.9 (hit-time hit)))
    (cond ((< (* (vy vel) (vy normal)) 0) (setf (vy vel) 0))
          ((< (* (vx vel) (vx normal)) 0) (setf (vx vel) 0)))
    (nv+ vel (velocity other))
    ;; Zip out of ground in case of clipping
    (cond ((and (/= 0 (vy normal))
                (< (vy pos) (vy loc))
                (< (- (vy loc) (vy bsize))
                   (+ (vy pos) (vy psize))))
           (setf (vy loc) (+ (vy pos) (vy psize) (vy bsize))))
          ((and (/= 0 (vy normal))
                (< (vy loc) (vy pos))
                (< (- (vy pos) (vy psize))
                   (+ (vy loc) (vy bsize))))
           (setf (vy loc) (- (vy pos) (vy psize) (vy bsize))))
          ((and (/= 0 (vx normal))
                (< (vx pos) (vx loc))
                (< (- (vx loc) (vx bsize))
                   (+ (vx pos) (vx psize))))
           (setf (vx loc) (+ (vx pos) (vx psize) (vx bsize))))
          ((and (/= 0 (vx normal))
                (< (vx loc) (vx pos))
                (< (- (vx pos) (vx psize))
                   (+ (vx loc) (vx bsize))))
           (setf (vx loc) (- (vx pos) (vx psize) (vx bsize)))))))

(defmethod collides-p ((moving moving) (stopper stopper) hit) NIL)
